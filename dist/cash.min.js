/*! cash-dom 1.3.5, https://github.com/kenwheeler/cash @license MIT */
!function(e,t){"function"==typeof define&&define.amd?define(t):"undefined"!=typeof exports?module.exports=t():e.cash=e.$=t()}(this,function(){function e(e,t){return t=t||$,K.test(e)?t.getElementsByClassName(e.slice(1)):ee.test(e)?t.getElementsByTagName(e):t.querySelectorAll(e)}function t(e){if(!ne){const e=(ne=$.implementation.createHTMLDocument()).createElement("base");e.href=$.location.href,ne.head.appendChild(e)}const t=te.exec(e);return t?[ne.createElement(t[1])]:(ne.body.innerHTML=e,ne.body.childNodes)}function n(e){"loading"!==$.readyState?e():$.addEventListener("DOMContentLoaded",e)}function i(i,r){if(!i)return this;
// If already a cash collection, don't do any further processing
if(i.cash&&i!==H)return i;let s,o=i,a=0;if(G(i))o=
// If an ID use the faster getElementById check
J.test(i)?$.getElementById(i.slice(1)):Q.test(i)?t(i):e(i,r);else if(Z(i))
// If function, use as shortcut for DOM ready
return n(i),this;if(!o)return this;
// If a single DOM element is passed in or received via ID, return the single element
if(o.nodeType||o===H)this[0]=o,this.length=1;else for(
// Treat like an array and loop through each item.
s=this.length=o.length;a<s;a++)this[a]=o[a];return this}function r(e,t){return new i(e,t)}/* jshint laxbreak: true */
function s(e){return e[r.uid]=e[r.uid]||{}}function o(e,t,n){return s(e)[t]=n}function a(e,t){const n=s(e);return void 0===n[t]&&(n[t]=e.dataset?e.dataset[t]:r(e).attr("data-"+t)),n[t]}function l(e,t){const n=s(e);n?delete n[t]:e.dataset?delete e.dataset[t]:r(e).removeAttr("data-"+name)}function c(e){return r.isString(e)&&e.match(ie)}function u(e,t){return e.classList?e.classList.contains(t):new RegExp("(^| )"+t+"( |$)","gi").test(e.className)}function f(e,t,n){e.classList?e.classList.add(t):n.indexOf(` ${t} `)&&(e.className+=" "+t)}function h(e,t){e.classList?e.classList.remove(t):e.className=e.className.replace(t,"")}/* jshint laxbreak: true */
function d(e,t){return parseInt(H.getComputedStyle(e[0],null)[t],10)||0}/* jshint laxbreak: true, eqnull:true */
function p(e,t,n){const i=r.getData(e,"_cashEvents")||r.setData(e,"_cashEvents",{});i[t]=i[t]||[],i[t].push(n),e.addEventListener(t,n)}function m(e,t,n){const i=r.getData(e,"_cashEvents");let s=i&&i[t];if(s)if(n){e.removeEventListener(t,n);let i=s.indexOf(n);i>=0&&s.splice(i,1)}else r.each(s,n=>{e.removeEventListener(t,n)}),s=[]}function g(){return!0}function y(){return!1}function v(e,t,n){Object.defineProperty(e,n,{get:()=>t[n],set(e){t[n]=e}})}function b(e,t){return"&"+encodeURIComponent(e)+"="+encodeURIComponent(t).replace(/%20/g,"+")}function x(e){const t=[];return r.each(e.options,e=>{e.selected&&t.push(e.value)}),t.length?t:null}function w(e){const t=e.selectedIndex;return t>=0?e.options[t].value:null}function E(e){const t=e.type;if(!t)return null;switch(t.toLowerCase()){case"select-one":return w(e);case"select-multiple":return x(e);case"radio":case"checkbox":return e.checked?e.value:null;default:return r.isString(e.value)?e.value:null}}/* jshint laxbreak: true */
function N(e,t,n){if(n){const n=e.childNodes[0];e.insertBefore(t,n)}else e.appendChild(t)}function T(e,t,n){const i=r.isString(t);i||!t.length?r.each(e,i?e=>e.insertAdjacentHTML(n?"afterbegin":"beforeend",t):(e,i)=>N(e,0===i?t:t.cloneNode(!0),n)):r.each(t,t=>T(e,t,n))}/* jshint laxbreak: true, bitwise:false, maxstatements:23, maxcomplexity:13 */
function C(e){return!0===e.disabled&&("form"in e||"label"in e)}function S(e,t,n){const i="legend",s=le++,o=[0,s];let a,l,c;
// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
if(n){for(;e=e.parentNode;)if(1===e.nodeType&&C(e,t,n))return!0}else for(;e=e.parentNode;)if(1===e.nodeType)if(c=e[r.uid]||(e[r.uid]={}),
// Support: IE <9 only
// Defend against cloned attroperties (jQuery gh-1709)
l=c[e.uniqueID]||(c[e.uniqueID]={}),i===e.nodeName.toLowerCase())e=e.parentNode||e;else{if((a=l[i])&&0===a[0]&&a[1]===s)
// Assign to newCache so results back-propagate to previous elements
return o[2]=a[2];
// A match means we're done; a fail means we have to keep checking
if(
// Reuse newcache so results back-propagate to previous elements
l[i]=o,o[2]=C(e,t,n))return!0}return!1}/**
   * Handle both :enabled/:disabled pseudos
   * @param elem      The target element
   * @param disabled  true for :disabled; false for :enabled {Boolean};
   */
function L(e,t){
// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
// Only certain elements can match :enabled or :disabled
// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
// Only certain elements can match :enabled or :disabled
// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
// Check for inherited disabledness on relevant non-disabled elements:
// * listed form-associated elements in a disabled fieldset
//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
// * option elements in a disabled optgroup
//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
// All such elements have a 'form' property.
// Option elements defer to a parent optgroup if present
// Where there is no isDisabled, check manually
/* jshint -W018 */
return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&S(e)===t:e.disabled===t:"label"in e&&e.disabled===t}function A(e,t,n){console.warn("cash.animate:",e),r.isFunction(n.complete)&&n.complete.call(t,t,{error:e})}/** One requestAnimationFrame function */
function D(){let e,t,n=ue.length;if(!ue.playing||0===n)return ue.playing=!1,void(ue.frame=null);for(;n--;)(e=ue[n])&&!1===e()&&(t=ue.indexOf(e))>-1&&ue.splice(t,1);ue.frame=ce(D)}function O(e,t,n,i){function r(e){return e*(l+e*(c+e*u))}function s(e){return e*(f+e*(h+e*d))}
// using Newton's method to aproximate the parametric value of x for t
function o(e){return l+e*(2*c+3*u*e)}function a(e){let t,n=e,i=0;for(;i<3&&(// making 3 iterations max
t=r(n)-e,!(Math.abs(t)<.001));)// if already close enough
n-=t/o(n),i++;return n}if(1===arguments.length){if(he[e])return he[e];const t=fe.exec(e);return he[e]=t?O.apply(null,t.slice(1,5)):null}
// defining the bezier functions in the polynomial form
let l=3*e,c=3*(n-e)-l,u=1-l-c,f=3*t,h=3*(i-t)-f,d=1-f-h;return function(e){return s(a(e))}}function k(e,t){return function(n,i){return n=n||0===n?n:t,i?n:" "+e+"("+n+")"}}
////////////////////////////////////////
function F(e,t){const n={
// Set start & end as empty objects to be filled
start:{},end:{}},i=H.getComputedStyle(e);
// Use the existing transform style for the start.
n.start[de]=i[de]||"none",n.end[de]="";for(let e in t){let s=t[e];if(pe[e])/** Since we're using Element.animate, flatten the transforms object to a
         * single transform string.
         */
n.end[de]+=pe[e](s);else{/** Convert to vendor prefixed, camelCase property name */
const t=r.prefixedProp(e);let o=i[t];n.start[t]=o,n.end[t]=s}}return n.end[de]||(n.end[de]="none"),n}function B(e){const t=e.frameOpts,n=t.stagger*e.idex,i=t.direction,s=t.iterations,o=r.extend({},t,{delay:t.delay+n}),a="alternate"===i&&s%2||"normal"===i?e.endValues:null,l=e.obj.animate([e.startValues,e.endValues],o);return l.addEventListener("finish",function(){if(a)/** Apply the end state styles */
for(let t in a)e.target[t]=a[t];e.onFinished(e.obj,e.idex)}),l}function P(e,t,n){/**********************************************************************
     * Context bound animation helpers {
     *
     */
function i(t){let i=n;t.length&&(i=r.extend({},n,t[1]),t=t[0]),i.frameStart.call(e,e),r.each(e,function(e,n){const r=e.nodeType,o=r?e.style:e;/** Properties to animate */
let a={},l={},c={};if(r)l=(a=F(e,t)).start,c=a.end;else/** If we're dealing with a plain object, just set the start & end
           *  values
           */
for(let e in t)l[e]=o[e],c[e]=t[e];
// Use element.animate
return i.itemStart.call(e,e,n),B({target:o,obj:e,idex:n,frameOpts:i,startValues:l,endValues:c,onFinished:s})})}function s(r,s){n.itemComplete.call(r,r,s),--a||(n.frameComplete.call(e,e),++l<o?(a=e.length,i(t[l])):n.complete.call(e,e))}e=e.length?e:[e],t=t.length?t:[t],n=r.extend({},me,n);const o=t.length;let a=e.length,l=0;n.start.call(e,e);try{i(t[l])}catch(t){A(t,e,n)}}/**
   *  Given optional 'duration' and 'complete' parameters, generate an options
   *  object with proper values.
   *  @method __createOpts
   *  @param  [duration]    The duration {String | Number};
   *  @param  [completion]  A callback to invoke upon completion of the animation
   *                        {Function};
   *
   *  `duration` may be a time in ms or one of the following strings:
   *    'fast'    : 100ms
   *    'normal'  : 400ms
   *    'slow'    : 800ms
   *
   *  @return A new animation options object {Object};
   *  @private
   */
function j(e,t){const n={duration:e,complete:t};if(r.isFunction(e))n.duration=ge,n.complete=e;else if(r.isString(e))switch(e.toLowerCase()){case"fast":n.duration=100;break;case"normal":n.duration=ge;break;case"slow":n.duration=800;break;default:
// Remove any 'ms' suffix and default to 1.
n.duration=parseFloat(e)||1}return n}/**
   *  SlideUp/Down
   *  @method __slide
   *  @param  direction     The slide direction (Up | Down) {String};
   *  @param  [duration]    The duration {String | Number};
   *  @param  [completion]  A callback to invoke upon completion of the animation
   *                        {Function};
   *
   *  @return The animation;
   *  @private
   */
function q(e,t,n){const i=j(t,n),s=i.start,o=i.complete,a={// maintain explicit inline styles
/* ensure that 'height', 'overflow' and 'transform' are removed on
       * animation completion if not explicitly set in an inline style
       */
height:null,overflow:null,transform:null},l={};// ending state
return i.start=function(t){// exclude 'display' from the state
if(s&&s.call(t,t),/* Establish the target 'end' state.
       *
       * But first, extract any inline styles, excluding 'display'
       */
r.extend(a,r.parseStyle(t.attr("style"))),delete a.display,"Down"===e){/* 'slideDown'
         *
         * Recover any end-state hints provided by 'slideUp'
         */
const e=t.data("slideDown");if(e&&(t.removeData("slideDown"),r.extend(l,e)),!l.height){/* No idea how tall this element should be so move the element
           * off-screen to get measurements so we can establish the
           * target end-state for 'height'.
           *
           * Since we're effecting 'display', remember the starting value.
           */
const e=t.css("display");e&&"none"!==e&&(l.display=e),t.css({position:"absolute",top:"-99999px",left:"-99999px",display:"block"}),l.height=t.css("height")}/* Establish the initial starting state, possibly moving the element back
         * on-screen.
         */
t.css({position:a.position||null,top:a.top||null,left:a.left||null,display:"inline"===l.display?"inline-block":"block",height:0,overflow:"hidden"})}else{/* 'slideUp'
         *
         * Retrieve the current 'display' and 'height' to pass as hints to
         * 'slideDown'.
         */
const e={display:t.css("display"),height:t.css("height")};
// Establish the target end-state
l.display="none",l.height=0,
// Immediately change overflow
t.css("overflow","hidden"),
// Pass the collected hints to 'slideDown'
t.data("slideDown",e)}},i.complete=function(e,t){
// Resetting the element's inline styles to their pre-animation values.
e.css(a),o&&o.call(e,e,t)},this.animate(l,i)}/**
   *  FadeIn/To/Out
   *  @method __fade
   *  @param  opacity       The target opacity {Number};
   *  @param  [duration]    The duration {String | Number};
   *  @param  [completion]  A callback to invoke upon completion of the animation
   *                        {Function};
   *
   *  @return The animation;
   *  @private
   */
function I(e,t,n){const i=j(t,n),s=i.start,o=i.complete,a={// maintain explicit inline styles
/* ensure that 'transform' is removed on animation completion if not
       * explicitly set in an inline style
       */
transform:null},l={opacity:e};return i.start=function(e){s&&s.call(e,e),/* Establish the target 'end' state.
       *
       * But first, extract any inline styles, excluding 'opacity'
       */
r.extend(a,r.parseStyle(e.attr("style"))),delete a.opacity},i.complete=function(e,t){
// Resetting the element's inline styles to their pre-animation values.
e.css(a),o&&o.call(e,e,t)},this.animate(l,i)}/**
   *  Identify objects that require special attention.
   *  @method _isSpecial
   *  @param  obj   The object in question {Object};
   *
   *  @return true | false
   */
function M(e){return e instanceof Date||e instanceof RegExp||"undefined"!=typeof Buffer&&e instanceof Buffer}/**
   *  Clone an object that require special attention.
   *  @method _cloneSpecial
   *  @param  obj   The special object to clone {Object};
   *
   *  @return A deep clone of `obj` {Mixed};
   */
function U(e){let t=e;return e instanceof Date?t=new Date(e.getTime()):e instanceof RegExp?t=new RegExp(e):"undefined"!=typeof Buffer&&e instanceof Buffer?(t=new Buffer(e.length),e.copy(t)):(console.warn("$._cloneSpecial(): Unexpected object"),t=Object.assign({},e)),t}/**
   *  Recursively clone an array.
   *  @method _cloneArray
   *  @param  ar    The target array {Array};
   *
   *  @return A deep clone of `ar` {Array};
   */
function R(e){return e.map(e=>{let t=e;return null!==e&&"object"==typeof e&&(t=Array.isArray(e)?R(e):M(e)?U(e):_({},e)),t})}/**
   *  Perform a jQuery-like deep extend.
   *  @method _cloneDeep
   *  @param  target    The target of the extend {Object};
   *  @param  ...       Objects with which to extend `target` {Mixed};
   *
   *  @return `this` for a fluent interface {cash};
   */
function _(e,...t){const n=e||{};// new value
/* If the new value isn't an object, then just overwrite by the new
         * value.
         */
// Recursively clone arrays.
// Custom cloning and overwrites for specific objects
// If the source isn't an object or array, simply overwrite
// Source and new values are both objects.
return t.forEach(t=>{null===t||"object"!=typeof t||Array.isArray(t)||Object.keys(t).forEach(i=>{const r=e[i],s=t[i];s!==e&&(null!==s&&"object"==typeof s?Array.isArray(s)?n[i]=R(s):M(s)?n[i]=U(s):null===r||"object"!=typeof r||Array.isArray(r)?n[i]=_({},s):n[i]=_(r,s):n[i]=s)})}),n}const $=document,H=window,W=Array.prototype,V=W.slice,X=W.filter,Y=W.push,z=function(){},Z=function(e){
// @see https://crbug.com/568448
return typeof e==typeof z&&e.call},G=function(e){return"string"==typeof e},J=/^#[\w-]*$/,K=/^\.[\w-]*$/,Q=/<.+>/,ee=/^\w+$/,te=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;var ne;Object.defineProperties(r.prototype,{constructor:{value:r},init:{value:i},push:{value:Y},splice:{value:W.splice},map:{value:W.map},cash:{value:!0,enumerable:!0},length:{value:0,enumerable:!0,writable:!0},ready:n}),Object.defineProperties(r,{uid:{value:"_cash"+Date.now()},fn:{value:r.prototype},parseHTML:{value:t},noop:{value:z},isWindow:{value:function(e){return e===H}},isFunction:{value:Z},isString:{value:G},find:{value:e},proxy:{value:function(e,t){if(r.isString(t)){
// Bind a named method
const n=e[t];t=e,e=n}if(r.isFunction(e))return e.bind(t)}}}),i.prototype=r.prototype,
// Upgrade extend
r.extend=r.fn.extend=function(e){e=e||{};const t=V.call(arguments);let n=t.length,i=1;for(1===t.length&&(e=this,i=0);i<n;i++)if(t[i])for(let n in t[i])t[i].hasOwnProperty(n)&&(e[n]=t[i][n]);return e},r.extend({merge(e,t){const n=+t.length;let i=e.length,r=0;for(;r<n;i++,r++)e[i]=t[r];return e.length=i,e},each:/* jshint laxbreak: true */
function(e,t){const n=e.length;if(void 0===n)
// Object iteration
for(let n in e){const i=e[n];/* Support jQuery's backwards parameter list for each over objects:
         *    callback( key, val )  vs ES6 callback( val, key )
         */
if(!1===t.call(i,n,i,e))break}else{
// Array iteration
let i=0;for(;i<n;i++){const n=e[i];if(!1===t.call(n,n,i,e))break}}},matches:function(e,t){const n=e&&(e.matches||e.webkitMatchesSelector||e.mozMatchesSelector||e.msMatchesSelector||e.oMatchesSelector);return!!n&&n.call(e,t)},unique:function(e){return r(V.call(e).filter((e,t,n)=>n.indexOf(e)===t))},selectComparator:function(e){/* Use browser's `matches` function if string */
return r.isString(e)?r.matches:e.cash?t=>e.is(t):function(e,t){return e===t}},isArray:Array.isArray,isNumeric:e=>!isNaN(parseFloat(e))&&isFinite(e)}),r.fn.extend({data(e,t){if(r.isString(e))return void 0===t?a(this[0],e):this.each(n=>o(n,e,t));for(let t in e)this.data(t,e[t]);return this},removeData(e){return this.each(t=>l(t,e))}}),r.getData=a,r.setData=o;/* jshint laxbreak: true */
const ie=/\S+/g;r.fn.extend({addClass(e){const t=c(e);return t?this.each(e=>{const n=` ${e.className} `;r.each(t,t=>{f(e,t,n)})}):this},attr(e,t){if(e){if(r.isString(e))return void 0===t?this[0]?this[0].getAttribute?this[0].getAttribute(e):this[0][e]:void 0:this.each(n=>{n.setAttribute?n.setAttribute(e,t):n[e]=t});for(let t in e)this.attr(t,e[t]);return this}},hasClass(e){const t=c(e);let n=!1;return t&&t.length&&this.each(e=>!(n=u(e,t[0]))),n},prop(e,t){if(r.isString(e))return void 0===t?this[0][e]:this.each(n=>{n[e]=t});for(let t in e)this.prop(t,e[t]);return this},removeAttr(e){return this.each(t=>{t.removeAttribute?t.removeAttribute(e):delete t[e]})},removeClass(e){if(!arguments.length)return this.attr("class","");const t=c(e);return t?this.each(e=>{r.each(t,t=>{h(e,t)})}):this},removeProp(e){return this.each(t=>{delete t[e]})},toggleClass(e,t){if(void 0!==t)return this[t?"addClass":"removeClass"](e);const n=c(e);return n?this.each(e=>{const t=` ${e.className} `;r.each(n,n=>{u(e,n)?h(e,n):f(e,n,t)})}):this}}),/* jshint laxbreak: true */
r.fn.extend({add(e,t){return r.unique(r.merge(this,r(e,t)))},each(e){return r.each(this,e),this},eq(e){return r(this.get(e))},filter(e){if(!e)return this;const t=r.isFunction(e)?e:r.selectComparator(e);return r(X.call(this,n=>t(n,e)))},first(){return this.eq(0)},get(e){return void 0===e?V.call(this):e<0?this[e+this.length]:this[e]},index(e){const t=e?r(e)[0]:this[0],n=e?this:r(t).parent().children();return V.call(n).indexOf(t)},last(){return this.eq(-1)}});/* jshint laxbreak: true */
const re=function(){const e=/(?:^\w|[A-Z]|\b\w)/g,t=/[\s-_]+/g;return function(n){return n.replace(e,(e,t)=>e[0===t?"toLowerCase":"toUpperCase"]()).replace(t,"")}}(),se=function(){const e={},t=document.createElement("div").style,n=["webkit","moz","ms","o"];return function(i){if(i=re(i),e[i])return e[i];const s=i.charAt(0).toUpperCase()+i.slice(1),o=(i+" "+n.join(s+" ")+s).split(" ");return r.each(o,n=>{if(n in t)return e[n]=n=e[n]=n,!1}),e[i]}}(),oe=function(){const e=/\s*;\s*/,t=/\s*:\s*/;return function(n){const i={};return r.isString(n)&&n.split(e).forEach(e=>{if(!e)return;const[n,r]=e.split(t);i[n]=r}),i}}();r.prefixedProp=se,r.camelCase=re,r.parseStyle=oe,r.fn.extend({css(e,t){if(r.isString(e))return e=se(e),arguments.length>1?this.each(n=>n.style[e]=t):H.getComputedStyle(this[0])[e];for(let t in e)this.css(t,e[t]);return this}}),r.each(["Width","Height"],e=>{const t=e.toLowerCase();r.fn[t]=function(n){const i=this[0];
// set
return r.isWindow(i)?i.document.documentElement["client"+e]:void 0===n?i.getBoundingClientRect()[t]:(i.style[t]=n,this)},r.fn["inner"+e]=function(){const t=this[0];return r.isWindow(t)?t.document.documentElement["client"+e]:t["client"+e]},r.fn["outer"+e]=function(t){const n=this[0];return r.isWindow(n)?n["inner"+e]:n["offset"+e]+(t?d(this,"margin"+("Width"===e?"Left":"Top"))+d(this,"margin"+("Width"===e?"Right":"Bottom")):0)}}),r.Event=function(e,t){
// Allow instantiation without 'new'
if(!(this instanceof r.Event))return new r.Event(e,t);const n=e&&e.type&&e instanceof Event?e:new CustomEvent(e);
// Mirror all properties of the source event
for(let e in n)t&&e in t||"target"===e||"currentTarget"===e?
// Properties that need to be modifiable (and thus not directly mirrored)
this[e]=n[e]:
// Actually reference the source event
v(this,n,e);this.originalEvent=n,
// The target should NOT be a text node
n.target&&3===n.target.nodeType&&(this.target=n.target.parentNode),
// Include explicitly provided properties
t&&r.extend(this,t),
// Include a jQuery-like isDefaultPrevented()'
this.isDefaultPrevented=n.defaultPrevented||void 0===n.defaultPrevented&&!1===n.returnValue?g:y,
// Create a timestamp if the incoming event doesn't have one
null==this.timeStamp&&(this.timeStamp=Date.now()),
// Mark this event as "fixed"
this[r.uid]=!0},r.fn.extend({off(e,t){return this.each(n=>m(n,e,t))},on(e,t,n,i){// jshint ignore:line
if(!r.isString(e)){for(let n in e)this.on(n,t,e[n]);return this}if(r.isFunction(t)&&(n=t,t=null),"ready"===e)return r.onReady(n),this;if(r.isFunction(n)||!1!==t){if(t){const e=n;n=function(n){let i=n.target;for(;!r.matches(i,t);){if(i===this)return i=!1;i=i.parentNode}if(i){
// Make a writable Event adjusted for delegation
const t=r.Event(n,{delegateTarget:n.currentTarget,currentTarget:i});e.call(i,t)}}}}else
// Handle on('event', false) to squelch an event
n=y;return this.each(t=>{let r=n;i&&(r=function(){n.apply(this,arguments),m(t,e,r)}),p(t,e,r)})},one(e,t,n){return this.on(e,t,n,!0)},trigger(e,t){const n=$.createEvent("HTMLEvents");return n.data=t,n.initEvent(e,!0,!1),this.each(e=>e.dispatchEvent(n))},focus(){
//return this;
return this.each(e=>e.focus())},blur(){
//return this;
return this.each(e=>e.blur())}}),r.fn.extend({serialize(){let e="";return r.each(this[0].elements||this,t=>{if(t.disabled||"FIELDSET"===t.tagName)return;const n=t.name;switch(t.type.toLowerCase()){case"file":case"reset":case"submit":case"button":break;case"select-multiple":const i=E(t);null!==i&&r.each(i,t=>{e+=b(n,t)});break;default:const s=E(t);null!==s&&(e+=b(n,s))}}),e.substr(1)},val(e){return void 0===e?E(this[0]):this.each(t=>t.value=e)}}),r.fn.extend({after(e){return r(e).insertAfter(this),this},append(e){return T(this,e),this},appendTo(e){return T(r(e),this),this},before(e){return r(e).insertBefore(this),this},clone(){return r(this.map(e=>e.cloneNode(!0)))},empty(){return this.html(""),this},html(e){if(void 0===e)return this[0].innerHTML;const t=e.nodeType?e[0].outerHTML:e;return this.each(e=>e.innerHTML=t)},insertAfter(e){return r(e).each((e,t)=>{const n=e.parentNode,i=e.nextSibling;this.each(e=>{n.insertBefore(0===t?e:e.cloneNode(!0),i)})}),this},insertBefore(e){return r(e).each((e,t)=>{const n=e.parentNode;this.each(i=>{n.insertBefore(0===t?i:i.cloneNode(!0),e)})}),this},prepend(e){return T(this,e,!0),this},prependTo(e){return T(r(e),this,!0),this},remove(){return this.each(e=>e.parentNode.removeChild(e))},text(e){return void 0===e?this[0].textContent:this.each(t=>t.textContent=e)}});const ae=$.documentElement;r.fn.extend({position(){const e=this[0];return{left:e.offsetLeft,top:e.offsetTop}},offset(){const e=this[0].getBoundingClientRect();return{top:e.top+H.pageYOffset-ae.clientTop,left:e.left+H.pageXOffset-ae.clientLeft}},offsetParent(){return r(this[0].offsetParent)}});let le=0;r._pseudos={focus:e=>e===document.activeElement&&(!document.hasFocus||document.hasFocus())&&!!(e.type||e.href||~e.tabIndex),enabled:e=>L(e,!1),disabled:e=>L(e,!0),checked:e=>{
// In CSS3, :checked should return both checked and selected elements
// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
const t=e.nodeName;return"INPUT"===t&&!!e.checked||"OPTION"===t&&!!e.selected},selected:e=>!0===e.selected,empty:e=>{
// http://www.w3.org/TR/selectors/#empty-pseudo
// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
//   but not by others (comment: 8; processing instruction: 7; etc.)
// nodeType < 6 works because attributes (2) do not appear as children
for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},input:e=>["INPUT","SELECT","TEXTAREA","BUTTON"].includes(e.nodeName),button:e=>{const t=e.nodeName;return"INPUT"===t&&"button"===e.type||"BUTTON"===t}},/* jshint laxbreak: true */
r.fn.extend({children(e){let t=[];return this.each(e=>{t.push.apply(t,e.children)}),t=r.unique(t),e?t.filter(t=>r.matches(t,e)):t},closest(e){return!e||this.length<1?r():this.is(e)?this.filter(e):this.parent().closest(e)},is(e){if(!e)return!1;let t=r.selectComparator(e);if(r._pseudos&&":"===e[0]){const n=r._pseudos[e.slice(1)];r.isFunction(n)?t=n:console.error("unsupported pseudo: "+e)}let n=!1;return this.each(i=>!(n=t(i,e))),n},find(e){if(!e||e.nodeType)return r(e&&this.has(e).length?e:null);let t=[];if(r._pseudos&&":"===e[0]){const n=r._pseudos[e.slice(1)];r.isFunction(n)?t=this.filter(e=>n(e)):console.error("unsupported pseudo: "+e)}else this.each(n=>{t.push.apply(t,r.find(e,n))});return r.unique(t)},has(e){const t=r.isString(e)?t=>0!==r.find(e,t).length:t=>t.contains(e);return this.filter(t)},next(){return r(this[0].nextElementSibling)},not(e){if(!e)return this;const t=r.selectComparator(e);return this.filter(n=>!t(n,e))},parent(){const e=[];return this.each(t=>{t&&t.parentNode&&e.push(t.parentNode)}),r.unique(e)},parents(e){const t=[];let n;return this.each(i=>{for(n=i;n&&n.parentNode&&n!==$.body.parentNode;)n=n.parentNode,(!e||e&&r.matches(n,e))&&t.push(n)}),r.unique(t)},prev(){return r(this[0].previousElementSibling)},siblings(){const e=this.parent().children(),t=this[0];return e.filter(e=>e!==t)}});/**
   *  Converted to ES6 for Electron from the excellent work by
   *    shshaw        : https://github.com/shshaw
   *    Tommie Hansen : https://github.com/tommiehansen
   *
   *****************************************************************************
   *
   * @todo: Convert % to px
   * @todo: Ensure compatibility between Element.animate & requestAnimationFrame
   *        version
   * @todo: Compatibility in ease functions & Element.animate
   * @todo: transform: rotate compatibility. Element.animate seems to rotate the
   *        quickest possible way, not the correct way.
   * @todo: support 'fill' property
   */
/* jshint laxbreak:true, maxparams:6, eqnull:true, latedef:false */
const ce=H.requestAnimationFrame||H.webkitRequestAnimationFrame,ue=[];ue.play=function(){/* Prevent calling `requestAnimationFrame` twice if a frame is already
     * requested.
     */
ue.frame=ue.frame||ce(D),ue.playing=!0},r.animations=ue;
////////////////////////////////////////
/**
   * Easing delta functions thanks to Nikolay Nemshilov
   * See https://st-on-it.blogspot.com/2011/05/calculating-cubic-bezier-function.html
   */
const fe=/cubic-bezier\(([\d\.]+),\s+?([\d\.]+),\s+?([\d\.]+),\s+?([\d\.]+)\)/i;let he={linear:function(e){return e}};r.extend(he,{ease:O(.25,.1,.25,1),"ease-in":O(.42,0,1,1),"ease-out":O(0,0,.58,1),"ease-in-out":O(.42,0,.58,1)}),r.easings=he;
////////////////////////////////////////
/** Build transform conversion functions with defaults values */
const de=r.prefixedProp("transform"),pe={};r.each("rotate rotateX rotateY rotateZ skew skewX skewY".split(" "),function(e){pe[e]=k(e,"0deg")}),r.each("x y z".split(" "),function(e){const t="translate"+e.toUpperCase();pe[t]=pe[e]=k(t,0)}),r.each("scale scaleX scaleY scaleZ".split(" "),function(e){pe[e]=k(e,1)});
////////////////////////////////////////
const me={iterations:1,duration:400,easing:"linear",delay:0,stagger:0,reversed:!1,direction:"normal",fill:"both",start:r.noop,// animation start
complete:r.noop,// animation complete
itemStart:r.noop,// an item's animation has started
itemProgress:r.noop,/* an item's values have changed
                                * (currently only for requestAnimationFrame
                                *  animations)
                                */
itemComplete:r.noop,// an item's animation has completed
frameStart:r.noop,// a new keyframe has started
frameComplete:r.noop};r.animate=function(e,t,n){return e&&e.length?new P(e,t,n):A("empty collection",e,n)},r.fn.animate=function(e,t){return this.length?new P(this,e,t):A("empty collection",this,t)};/***************************************************************
   * jQuery Animations {
   *
   */
const ge=400;r.fn.extend({show(e,t){return null==e&&null==t?this.css("display",null):I.call(this,1,e,t)},hide(e,t){return null==e&&null==t?this.css("display","none"):I.call(this,0,e,t)},fadeIn(e,t){return I.call(this,1,e,t)},fadeOut(e,t){return I.call(this,0,e,t)},fadeTo(e,t,n){return I.call(this,t,e,n)},slideUp(e,t){return q.call(this,"Up",e,t)},slideDown(e,t){return q.call(this,"Down",e,t)}});/* jQuery Animations }
   ***************************************************************/
/* jshint laxbreak:true, latedef:false */
/* globals Buffer */
const ye=r.extend;
// Upgrade extend to allow deep extend if first argument is true.
/* jshint laxbreak: true */
// Create scrollLeft and scrollTop methods
return r.extend=r.fn.extend=function(e){return!0===e&&arguments.length>1?_.apply(this,V.call(arguments,1)):ye.apply(this,arguments)},r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},(e,t)=>{const n="pageYOffset"===t;r.fn[e]=function(i){return this.each(function(){let s;if(r.isWindow(this)?s=this:9===this.nodeType&&(s=this.defaultView),void 0===i)return s?s[t]:this[e];s?s.scrollTo(n?s.pageXOffset:i,n?i:s.pageYOffset):this[e]=i}),this}}),r});