/*! cash-dom 1.3.5, https://github.com/kenwheeler/cash @license MIT */
!function(t,e){"function"==typeof define&&define.amd?define(e):"undefined"!=typeof exports?module.exports=e():t.cash=t.$=e()}(this,function(){function t(t,e){return e=e||O,U.test(t)?e.getElementsByClassName(t.slice(1)):V.test(t)?e.getElementsByTagName(t):e.querySelectorAll(t)}function e(t){if(!_){const t=(_=O.implementation.createHTMLDocument()).createElement("base");t.href=O.location.href,_.head.appendChild(t)}return _.body.innerHTML=t,_.body.childNodes}function n(t){"loading"!==O.readyState?t():O.addEventListener("DOMContentLoaded",t)}function r(r,i){if(!r)return this;
// If already a cash collection, don't do any further processing
if(r.cash&&r!==F)return r;let s,o=r,a=0;if(j(r))o=
// If an ID use the faster getElementById check
I.test(r)?O.getElementById(r.slice(1)):z.test(r)?e(r):t(r,i);else if($(r))
// If function, use as shortcut for DOM ready
return n(r),this;if(!o)return this;
// If a single DOM element is passed in or received via ID, return the single element
if(o.nodeType||o===F)this[0]=o,this.length=1;else for(
// Treat like an array and loop through each item.
s=this.length=o.length;a<s;a++)this[a]=o[a];return this}function i(t,e){return new r(t,e)}function s(t){return t[X]=t[X]||{}}function o(t,e,n){return s(t)[e]=n}function a(t,e){const n=s(t);return void 0===n[e]&&(n[e]=t.dataset?t.dataset[e]:i(t).attr("data-"+e)),n[e]}function l(t,e){const n=s(t);n?delete n[e]:t.dataset?delete t.dataset[e]:i(t).removeAttr("data-"+name)}function c(t){return i.isString(t)&&t.match(Y)}function u(t,e){return t.classList?t.classList.contains(e):new RegExp("(^| )"+e+"( |$)","gi").test(t.className)}function h(t,e,n){t.classList?t.classList.add(e):n.indexOf(` ${e} `)&&(t.className+=" "+e)}function f(t,e){t.classList?t.classList.remove(e):t.className=t.className.replace(e,"")}/* jshint laxbreak: true */
function d(t,e){return parseInt(F.getComputedStyle(t[0],null)[e],10)||0}function p(t,e,n){const r=i.getData(t,"_cashEvents")||i.setData(t,"_cashEvents",{});r[e]=r[e]||[],r[e].push(n),t.addEventListener(e,n)}function m(t,e,n){const r=i.getData(t,"_cashEvents");let s=r&&r[e];if(s)if(n){t.removeEventListener(e,n);let r=s.indexOf(n);r>=0&&s.splice(r,1)}else i.each(s,n=>{t.removeEventListener(e,n)}),s=[]}function g(t,e){return"&"+encodeURIComponent(t)+"="+encodeURIComponent(e).replace(/%20/g,"+")}function y(t){const e=[];return i.each(t.options,t=>{t.selected&&e.push(t.value)}),e.length?e:null}function v(t){const e=t.selectedIndex;return e>=0?t.options[e].value:null}function b(t){const e=t.type;if(!e)return null;switch(e.toLowerCase()){case"select-one":return v(t);case"select-multiple":return y(t);case"radio":case"checkbox":return t.checked?t.value:null;default:return t.value?t.value:null}}/* jshint laxbreak: true */
function x(t,e,n){if(n){const n=t.childNodes[0];t.insertBefore(e,n)}else t.appendChild(e)}function w(t,e,n){const r=i.isString(e);r||!e.length?i.each(t,r?t=>t.insertAdjacentHTML(n?"afterbegin":"beforeend",e):(t,r)=>x(t,0===r?e:e.cloneNode(!0),n)):i.each(e,e=>w(t,e,n))}function C(t,e,n){console.warn("cash.animate:",t),i.isFunction(n.complete)&&n.complete.call(e,e,{error:t})}/** One requestAnimationFrame function */
function S(){let t,e,n=Q.length;if(!Q.playing||0===n)return Q.playing=!1,void(Q.frame=null);for(;n--;)(t=Q[n])&&!1===t()&&(e=Q.indexOf(t))>-1&&Q.splice(e,1);Q.frame=K(S)}function L(t,e,n,r){function i(t){return t*(l+t*(c+t*u))}function s(t){return t*(h+t*(f+t*d))}
// using Newton's method to aproximate the parametric value of x for t
function o(t){return l+t*(2*c+3*u*t)}function a(t){let e,n=t,r=0;for(;r<3&&(// making 3 iterations max
e=i(n)-t,!(Math.abs(e)<.001));)// if already close enough
n-=e/o(n),r++;return n}if(1===arguments.length){if(et[t])return et[t];const e=tt.exec(t);return et[t]=e?L.apply(null,e.slice(1,5)):null}
// defining the bezier functions in the polynomial form
let l=3*t,c=3*(n-t)-l,u=1-l-c,h=3*e,f=3*(r-e)-h,d=1-h-f;return function(t){return s(a(t))}}function N(t,e){return function(n,r){return n=n||0===n?n:e,r?n:" "+t+"("+n+")"}}
////////////////////////////////////////
function E(t,e){const n={
// Set start & end as empty objects to be filled
start:{},end:{}},r=F.getComputedStyle(t);
// Use the existing transform style for the start.
n.start[nt]=r[nt]||"none",n.end[nt]="";for(let t in e){let s=e[t];if(rt[t])/** Since we're using Element.animate, flatten the transforms object to a
         * single transform string.
         */
n.end[nt]+=rt[t](s);else{/** Convert to vendor prefixed, camelCase property name */
const e=i.prefixedProp(t);let o=r[e];n.start[e]=o,n.end[e]=s}}return n.end[nt]||(n.end[nt]="none"),n}function A(t){const e=t.frameOpts,n=e.stagger*t.idex,r=e.direction,s=e.iterations,o=i.extend({},e,{delay:e.delay+n}),a="alternate"===r&&s%2||"normal"===r?t.endValues:null,l=t.obj.animate([t.startValues,t.endValues],o);return l.addEventListener("finish",function(){if(a)/** Apply the end state styles */
for(let e in a)t.target[e]=a[e];t.onFinished(t.obj,t.idex)}),l}function T(t,e,n){/**********************************************************************
     * Context bound animation helpers {
     *
     */
function r(e){let r=n;e.length&&(r=i.extend({},n,e[1]),e=e[0]),r.frameStart.call(t,t),i.each(t,function(t,n){const i=t.nodeType,o=i?t.style:t;/** Properties to animate */
let a={},l={},c={};if(i)l=(a=E(t,e)).start,c=a.end;else/** If we're dealing with a plain object, just set the start & end
           *  values
           */
for(let t in e)l[t]=o[t],c[t]=e[t];
// Use element.animate
return r.itemStart.call(t,t,n),A({target:o,obj:t,idex:n,frameOpts:r,startValues:l,endValues:c,onFinished:s})})}function s(i,s){n.itemComplete.call(i,i,s),--a||(n.frameComplete.call(t,t),++l<o?(a=t.length,r(e[l])):n.complete.call(t,t))}t=t.length?t:[t],e=e.length?e:[e],n=i.extend({},it,n);const o=e.length;let a=t.length,l=0;n.start.call(t,t);try{r(e[l])}catch(e){C(e,t,n)}}/**
   *  Given optional 'duration' and 'complete' parameters, generate an options
   *  object with proper values.
   *  @method __createOpts
   *  @param  [duration]    The duration {String | Number};
   *  @param  [completion]  A callback to invoke upon completion of the animation
   *                        {Function};
   *
   *  `duration` may be a time in ms or one of the following strings:
   *    'fast'    : 100ms
   *    'normal'  : 400ms
   *    'slow'    : 800ms
   *
   *  @return A new animation options object {Object};
   *  @private
   */
function k(t,e){const n={duration:t,complete:e};if(i.isFunction(t))n.duration=st,n.complete=t;else if(i.isString(t))switch(t.toLowerCase()){case"fast":n.duration=100;break;case"normal":n.duration=st;break;case"slow":n.duration=800;break;default:
// Remove any 'ms' suffix and default to 1.
n.duration=parseFloat(t)||1}return n}/**
   *  SlideUp/Down
   *  @method __slide
   *  @param  direction     The slide direction (Up | Down) {String};
   *  @param  [duration]    The duration {String | Number};
   *  @param  [completion]  A callback to invoke upon completion of the animation
   *                        {Function};
   *
   *  @return The animation;
   *  @private
   */
function D(t,e,n){const r=k(e,n),s=r.start,o=r.complete,a={// maintain explicit inline styles
/* ensure that 'height', 'overflow' and 'transform' are removed on
       * animation completion if not explicitly set in an inline style
       */
height:null,overflow:null,transform:null},l={};// ending state
return r.start=function(e){// exclude 'display' from the state
if(s&&s.call(e,e),/* Establish the target 'end' state.
       *
       * But first, extract any inline styles, excluding 'display'
       */
i.extend(a,i.parseStyle(e.attr("style"))),delete a.display,"Down"===t){/* 'slideDown'
         *
         * Recover any end-state hints provided by 'slideUp'
         */
const t=e.data("slideDown");if(t&&(e.removeData("slideDown"),i.extend(l,t)),!l.height){/* No idea how tall this element should be so move the element
           * off-screen to get measurements so we can establish the
           * target end-state for 'height'.
           *
           * Since we're effecting 'display', remember the starting value.
           */
const t=e.css("display");t&&"none"!==t&&(l.display=t),e.css({position:"absolute",top:"-99999px",left:"-99999px",display:"block"}),l.height=e.css("height")}/* Establish the initial starting state, possibly moving the element back
         * on-screen.
         */
e.css({position:a.position||null,top:a.top||null,left:a.left||null,display:"inline"===l.display?"inline-block":"block",height:0,overflow:"hidden"})}else{/* 'slideUp'
         *
         * Retrieve the current 'display' and 'height' to pass as hints to
         * 'slideDown'.
         */
const t={display:e.css("display"),height:e.css("height")};
// Establish the target end-state
l.display="none",l.height=0,
// Immediately change overflow
e.css("overflow","hidden"),
// Pass the collected hints to 'slideDown'
e.data("slideDown",t)}},r.complete=function(t,e){
// Resetting the element's inline styles to their pre-animation values.
t.css(a),o&&o.call(t,t,e)},this.animate(l,r)}/**
   *  FadeIn/To/Out
   *  @method __fade
   *  @param  opacity       The target opacity {Number};
   *  @param  [duration]    The duration {String | Number};
   *  @param  [completion]  A callback to invoke upon completion of the animation
   *                        {Function};
   *
   *  @return The animation;
   *  @private
   */
function M(t,e,n){const r=k(e,n),s=r.start,o=r.complete,a={// maintain explicit inline styles
/* ensure that 'transform' is removed on animation completion if not
       * explicitly set in an inline style
       */
transform:null},l={opacity:t};return r.start=function(t){s&&s.call(t,t),/* Establish the target 'end' state.
       *
       * But first, extract any inline styles, excluding 'opacity'
       */
i.extend(a,i.parseStyle(t.attr("style"))),delete a.opacity},r.complete=function(t,e){
// Resetting the element's inline styles to their pre-animation values.
t.css(a),o&&o.call(t,t,e)},this.animate(l,r)}const O=document,F=window,q=Array.prototype,B=q.slice,P=q.filter,H=q.push,R=function(){},$=function(t){
// @see https://crbug.com/568448
return typeof t==typeof R&&t.call},j=function(t){return"string"==typeof t},I=/^#[\w-]*$/,U=/^\.[\w-]*$/,z=/<.+>/,V=/^\w+$/;var _;Object.defineProperties(i.prototype,{constructor:{value:i},init:{value:r},push:{value:H},splice:{value:q.splice},map:{value:q.map},cash:{value:!0,enumerable:!0},length:{value:0,enumerable:!0,writable:!0},ready:n}),Object.defineProperties(i,{fn:{value:i.prototype},parseHTML:{value:e},noop:{value:R},isFunction:{value:$},isString:{value:j},find:{value:t}}),r.prototype=i.prototype,
// Upgrade extend
i.extend=i.fn.extend=function(t){t=t||{};const e=B.call(arguments);let n=e.length,r=1;for(1===e.length&&(t=this,r=0);r<n;r++)if(e[r])for(let n in e[r])e[r].hasOwnProperty(n)&&(t[n]=e[r][n]);return t},i.extend({merge(t,e){const n=+e.length;let r=t.length,i=0;for(;i<n;r++,i++)t[r]=e[i];return t.length=r,t},each:/* jshint laxbreak: true */
function(t,e){const n=t.length;let r=0;for(;r<n&&!1!==e.call(t[r],t[r],r,t);r++);},matches:function(t,e){const n=t&&(t.matches||t.webkitMatchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector);return!!n&&n.call(t,e)},unique:function(t){return i(B.call(t).filter((t,e,n)=>n.indexOf(t)===e))},selectComparator:function(t){/* Use browser's `matches` function if string */
return i.isString(t)?i.matches:t.cash?e=>t.is(e):function(t,e){return t===e}},isArray:Array.isArray,isNumeric:t=>!isNaN(parseFloat(t))&&isFinite(t)});/* jshint laxbreak: true */
const X=i.uid="_cash"+Date.now();i.fn.extend({data(t,e){if(i.isString(t))return void 0===e?a(this[0],t):this.each(n=>o(n,t,e));for(let e in t)this.data(e,t[e]);return this},removeData(t){return this.each(e=>l(e,t))}}),i.getData=a,i.setData=o;/* jshint laxbreak: true */
const Y=/\S+/g;i.fn.extend({addClass(t){const e=c(t);return e?this.each(t=>{const n=` ${t.className} `;i.each(e,e=>{h(t,e,n)})}):this},attr(t,e){if(t){if(i.isString(t))return void 0===e?this[0]?this[0].getAttribute?this[0].getAttribute(t):this[0][t]:void 0:this.each(n=>{n.setAttribute?n.setAttribute(t,e):n[t]=e});for(let e in t)this.attr(e,t[e]);return this}},hasClass(t){const e=c(t);let n=!1;return e&&e.length&&this.each(t=>!(n=u(t,e[0]))),n},prop(t,e){if(i.isString(t))return void 0===e?this[0][t]:this.each(n=>{n[t]=e});for(let e in t)this.prop(e,t[e]);return this},removeAttr(t){return this.each(e=>{e.removeAttribute?e.removeAttribute(t):delete e[t]})},removeClass(t){if(!arguments.length)return this.attr("class","");const e=c(t);return e?this.each(t=>{i.each(e,e=>{f(t,e)})}):this},removeProp(t){return this.each(e=>{delete e[t]})},toggleClass(t,e){if(void 0!==e)return this[e?"addClass":"removeClass"](t);const n=c(t);return n?this.each(t=>{const e=` ${t.className} `;i.each(n,n=>{u(t,n)?f(t,n):h(t,n,e)})}):this}}),/* jshint laxbreak: true */
i.fn.extend({add(t,e){return i.unique(i.merge(this,i(t,e)))},each(t){return i.each(this,t),this},eq(t){return i(this.get(t))},filter(t){if(!t)return this;const e=i.isFunction(t)?t:i.selectComparator(t);return i(P.call(this,n=>e(n,t)))},first(){return this.eq(0)},get(t){return void 0===t?B.call(this):t<0?this[t+this.length]:this[t]},index(t){const e=t?i(t)[0]:this[0],n=t?this:i(e).parent().children();return B.call(n).indexOf(e)},last(){return this.eq(-1)}});/* jshint laxbreak: true */
const W=function(){const t=/(?:^\w|[A-Z]|\b\w)/g,e=/[\s-_]+/g;return function(n){return n.replace(t,(t,e)=>t[0===e?"toLowerCase":"toUpperCase"]()).replace(e,"")}}(),Z=function(){const t={},e=document.createElement("div").style,n=["webkit","moz","ms","o"];return function(r){if(r=W(r),t[r])return t[r];const s=r.charAt(0).toUpperCase()+r.slice(1),o=(r+" "+n.join(s+" ")+s).split(" ");return i.each(o,n=>{if(n in e)return t[n]=n=t[n]=n,!1}),t[r]}}(),G=function(){const t=/\s*;\s*/,e=/\s*:\s*/;return function(n){const r={};return i.isString(n)&&n.split(t).forEach(t=>{if(!t)return;const[n,i]=t.split(e);r[n]=i}),r}}();i.prefixedProp=Z,i.camelCase=W,i.parseStyle=G,i.fn.extend({css(t,e){if(i.isString(t))return t=Z(t),arguments.length>1?this.each(n=>n.style[t]=e):F.getComputedStyle(this[0])[t];for(let e in t)this.css(e,t[e]);return this}}),i.each(["Width","Height"],t=>{const e=t.toLowerCase();i.fn[e]=function(){return this[0].getBoundingClientRect()[e]},i.fn["inner"+t]=function(){return this[0]["client"+t]},i.fn["outer"+t]=function(e){return this[0]["offset"+t]+(e?d(this,"margin"+("Width"===t?"Left":"Top"))+d(this,"margin"+("Width"===t?"Right":"Bottom")):0)}}),i.fn.extend({off(t,e){return this.each(n=>m(n,t,e))},on(t,e,n,r){// jshint ignore:line
if(!i.isString(t)){for(let n in t)this.on(n,e,t[n]);return this}if(i.isFunction(e)&&(n=e,e=null),"ready"===t)return i.onReady(n),this;if(e){const t=n;n=function(n){let r=n.target;for(;!i.matches(r,e);){if(r===this)return r=!1;r=r.parentNode}r&&t.call(r,n)}}return this.each(e=>{let i=n;r&&(i=function(){n.apply(this,arguments),m(e,t,i)}),p(e,t,i)})},one(t,e,n){return this.on(t,e,n,!0)},trigger(t,e){const n=O.createEvent("HTMLEvents");return n.data=e,n.initEvent(t,!0,!1),this.each(t=>t.dispatchEvent(n))}}),i.fn.extend({serialize(){let t="";return i.each(this[0].elements||this,e=>{if(e.disabled||"FIELDSET"===e.tagName)return;const n=e.name;switch(e.type.toLowerCase()){case"file":case"reset":case"submit":case"button":break;case"select-multiple":const r=b(e);null!==r&&i.each(r,e=>{t+=g(n,e)});break;default:const s=b(e);null!==s&&(t+=g(n,s))}}),t.substr(1)},val(t){return void 0===t?b(this[0]):this.each(e=>e.value=t)}}),i.fn.extend({after(t){return i(t).insertAfter(this),this},append(t){return w(this,t),this},appendTo(t){return w(i(t),this),this},before(t){return i(t).insertBefore(this),this},clone(){return i(this.map(t=>t.cloneNode(!0)))},empty(){return this.html(""),this},html(t){if(void 0===t)return this[0].innerHTML;const e=t.nodeType?t[0].outerHTML:t;return this.each(t=>t.innerHTML=e)},insertAfter(t){return i(t).each((t,e)=>{const n=t.parentNode,r=t.nextSibling;this.each(t=>{n.insertBefore(0===e?t:t.cloneNode(!0),r)})}),this},insertBefore(t){return i(t).each((t,e)=>{const n=t.parentNode;this.each(r=>{n.insertBefore(0===e?r:r.cloneNode(!0),t)})}),this},prepend(t){return w(this,t,!0),this},prependTo(t){return w(i(t),this,!0),this},remove(){return this.each(t=>t.parentNode.removeChild(t))},text(t){return void 0===t?this[0].textContent:this.each(e=>e.textContent=t)}});const J=O.documentElement;i.fn.extend({position(){const t=this[0];return{left:t.offsetLeft,top:t.offsetTop}},offset(){const t=this[0].getBoundingClientRect();return{top:t.top+F.pageYOffset-J.clientTop,left:t.left+F.pageXOffset-J.clientLeft}},offsetParent(){return i(this[0].offsetParent)}}),/* jshint laxbreak: true */
i.fn.extend({children(t){let e=[];return this.each(t=>{e.push.apply(e,t.children)}),e=i.unique(e),t?e.filter(e=>i.matches(e,t)):e},closest(t){return!t||this.length<1?i():this.is(t)?this.filter(t):this.parent().closest(t)},is(t){if(!t)return!1;const e=i.selectComparator(t);let n=!1;return this.each(r=>!(n=e(r,t))),n},find(t){if(!t||t.nodeType)return i(t&&this.has(t).length?t:null);const e=[];return this.each(n=>{e.push.apply(e,i.find(t,n))}),i.unique(e)},has(t){const e=i.isString(t)?e=>0!==i.find(t,e).length:e=>e.contains(t);return this.filter(e)},next(){return i(this[0].nextElementSibling)},not(t){if(!t)return this;const e=i.selectComparator(t);return this.filter(n=>!e(n,t))},parent(){const t=[];return this.each(e=>{e&&e.parentNode&&t.push(e.parentNode)}),i.unique(t)},parents(t){const e=[];let n;return this.each(r=>{for(n=r;n&&n.parentNode&&n!==O.body.parentNode;)n=n.parentNode,(!t||t&&i.matches(n,t))&&e.push(n)}),i.unique(e)},prev(){return i(this[0].previousElementSibling)},siblings(){const t=this.parent().children(),e=this[0];return t.filter(t=>t!==e)}});/**
   *  Converted to ES6 for Electron from the excellent work by
   *    shshaw        : https://github.com/shshaw
   *    Tommie Hansen : https://github.com/tommiehansen
   *
   *****************************************************************************
   *
   * @todo: Convert % to px
   * @todo: Ensure compatibility between Element.animate & requestAnimationFrame
   *        version
   * @todo: Compatibility in ease functions & Element.animate
   * @todo: transform: rotate compatibility. Element.animate seems to rotate the
   *        quickest possible way, not the correct way.
   * @todo: support 'fill' property
   */
/* jshint laxbreak:true, maxparams:6, eqnull:true, latedef:false */
const K=F.requestAnimationFrame||F.webkitRequestAnimationFrame,Q=[];Q.play=function(){/* Prevent calling `requestAnimationFrame` twice if a frame is already
     * requested.
     */
Q.frame=Q.frame||K(S),Q.playing=!0},i.animations=Q;
////////////////////////////////////////
/**
   * Easing delta functions thanks to Nikolay Nemshilov
   * See https://st-on-it.blogspot.com/2011/05/calculating-cubic-bezier-function.html
   */
const tt=/cubic-bezier\(([\d\.]+),\s+?([\d\.]+),\s+?([\d\.]+),\s+?([\d\.]+)\)/i;let et={linear:function(t){return t}};i.extend(et,{ease:L(.25,.1,.25,1),"ease-in":L(.42,0,1,1),"ease-out":L(0,0,.58,1),"ease-in-out":L(.42,0,.58,1)}),i.easings=et;
////////////////////////////////////////
/** Build transform conversion functions with defaults values */
const nt=i.prefixedProp("transform"),rt={};i.each("rotate rotateX rotateY rotateZ skew skewX skewY".split(" "),function(t){rt[t]=N(t,"0deg")}),i.each("x y z".split(" "),function(t){const e="translate"+t.toUpperCase();rt[e]=rt[t]=N(e,0)}),i.each("scale scaleX scaleY scaleZ".split(" "),function(t){rt[t]=N(t,1)});
////////////////////////////////////////
const it={iterations:1,duration:400,easing:"linear",delay:0,stagger:0,reversed:!1,direction:"normal",fill:"both",start:i.noop,// animation start
complete:i.noop,// animation complete
itemStart:i.noop,// an item's animation has started
itemProgress:i.noop,/* an item's values have changed
                                * (currently only for requestAnimationFrame
                                *  animations)
                                */
itemComplete:i.noop,// an item's animation has completed
frameStart:i.noop,// a new keyframe has started
frameComplete:i.noop};i.animate=function(t,e,n){return t&&t.length?new T(t,e,n):C("empty collection",t,n)},i.fn.animate=function(t,e){return this.length?new T(this,t,e):C("empty collection",this,e)};/***************************************************************
   * jQuery Animations {
   *
   */
const st=400;/* jQuery Animations }
   ***************************************************************/
return i.fn.extend({show(t,e){return null==t&&null==e?this.css("display","block"):M.call(this,1,t,e)},hide(t,e){return null==t&&null==e?this.css("display","none"):M.call(this,0,t,e)},fadeIn(t,e){return M.call(this,1,t,e)},fadeOut(t,e){return M.call(this,0,t,e)},fadeTo(t,e,n){return M.call(this,e,t,n)},slideUp(t,e){return D.call(this,"Up",t,e)},slideDown(t,e){return D.call(this,"Down",t,e)}}),i});